@using RivetBlazor.Components
@using Models;
@using Models.Enums;
@using System.Threading;
@using System.Web;
@using Newtonsoft.Json;
@inject IHttpClientFactory ClientFactory;
@implements IDisposable;

<div class="rvt-border-bottom rvt-m-bottom-lg rvt-p-bottom-lg">
	<div class="rvt-flex">
		<div class="rvt-grow-1">
			<h2 class="rvt-ts-23 rvt-text-bold">Professional interests</h2>
		</div>
		<div class="rvt-m-left-sm">
			@if(CrudPerms.HasFlag(EntityPermissions.Post))
			{
				<button title="Edit Interests" class="rvt-button rvt-button--plain" data-modal-trigger="modal-form-expertise" @onclick=ResetForm>
					<rvt-icon name="pencil" />
					<span class="rvt-m-left-xs rvt-sr-only">Edit Interests</span>
				</button>
			}
		</div>
	</div>
	<p>What kinds of skills, technologies, or languages do you want to work with or learn about?</p>
	<ul class="rvt-list rvt-plain-list rvt-inline-list">
		@if (Person.Expertise != null)
		{
			@foreach (var Interest in Person.Expertise.Split(","))
			{
				<li><span class="rvt-badge">@Interest</span></li>
			}
		}
	</ul>
</div>
<ModalForm Id="modal-form-expertise" Title="Edit Interests" SubmitButtonText="Save Changes" Item=@ExpertiseAsList OnSubmit=@SaveChanges ConfirmBeforeClose=@ConfirmModalClose @ref=Mf>
	<DisplayException Ex=@Ex />
	<ul class="rvt-list rvt-plain-list rvt-inline-list">
		@foreach (var Interest in ExpertiseAsList)
		{
			<li>
				<span class="rvt-badge">@Interest
					<button type="button" class="rvt-button rvt-button--plain rvt-p-all-xxs" title="remove" style="height: auto;" @onclick="@(()=> RemoveInterest(Interest))">
						<rvt-icon name="trash"></rvt-icon><span class="rvt-sr-only">trash</span>
					</button>
				</span>
			</li>
		}
	</ul>
	
	<RivetInputText @bind-Value="SearchTerm" Label="Search" Placeholder="Type an Interest" Description="Type an interest and then click a button in the results below to add it to this profile." @oninput="e => SearchTermChanged(e.Value.ToString())" @onkeydown=SearchTermListenForEnter/>
	
	
	<ul class="rvt-plain-list rvt-border-all rvt-border-radius">
		@foreach (var enteredItem in Suggestions)
		{
			<li>
				<a class="rvt-button rvt-button--secondary rvt-button--full-width" @onclick=@(() => AddInterest(enteredItem)) >@enteredItem </a>
			</li>
		}
	</ul>
</ModalForm>


@code{
	[Parameter]
	public EntityPermissions CrudPerms { get; set; }
	[Parameter]
	public Person Person { get; set; }
	// Enable two-way binding.
	[Parameter]
    public EventCallback<Person> PersonChanged { get; set; }

	private HttpClient Api() => ClientFactory.CreateClient("Api");
	private List<string> ExpertiseAsList = new List<string>();
	private string SearchTerm = "";
	private ModalForm<List<string>> Mf;
	private bool ConfirmModalClose = false;
	private bool AddedByEnter = false;
	private List<string> Suggestions = new List<string>();
	private StackExchangeRequest SuggestionsRequest;
	private Exception Ex;

	private void ResetForm()
	{
		ExpertiseAsList = Person.Expertise
			.Split(",")
			.Select(e => e.Trim().ToLower())
			.ToList();
		Suggestions = new List<string>();
		SearchTerm = "";
		ConfirmModalClose = false;
		AddedByEnter = false;

		CancelSuggestionsRequestIfRunning();
		Mf.ResetState();
	}

	private async Task RemoveInterest(string interest)
	{	
		ExpertiseAsList.Remove(interest);
		
		// We've made a change, confirm closing the modal without saving changes.
		ConfirmModalClose = true;
		// Ensure that the submit button is available.
		Mf.ForceValid();
	}

	private async Task AddInterest(string interest)
	{
		if(string.IsNullOrWhiteSpace(interest))
		{
			return;
		}

		if(ExpertiseAsList.Contains(interest.Trim().ToLower()) == false)
		{
			ExpertiseAsList.Add(interest.Trim().ToLower());
		}

		// Reset the search term and clear-out suggestions.
		SearchTerm = "";
		SearchTermChanged(SearchTerm);

		// We've made a change, confirm closing the modal without saving changes.
		ConfirmModalClose = true;
		// Ensure that the submit button is available.
		Mf.ForceValid();
	}

	private void SearchTermListenForEnter(KeyboardEventArgs e)
	{
		if (e.Code == "Enter" || e.Code == "NumpadEnter")
		{
			AddedByEnter = true;
			AddInterest(SearchTerm);
		}
	}

	private async Task SaveChanges()
	{
		try
		{
			Person result;

			// Make an in-memory copy of Person to PUT to the server.
			var objToPut = JsonConvert.DeserializeObject<Person>(JsonConvert.SerializeObject(Person, Json.JsonSerializerSettings), Json.JsonSerializerSettings);
			// Update objToPut's Expertise
			objToPut.Expertise = string.Join(",", ExpertiseAsList);

			var url = $"/people/{Person.Id}";

			using (var apiClient = Api())
			{
				var reqJson = JsonConvert.SerializeObject(objToPut, Json.JsonSerializerSettings);
				var reqContent = new StringContent(reqJson, System.Text.Encoding.UTF8, "application/json");
				var response = await apiClient.PutAsync(url, reqContent);

				if(response.IsSuccessStatusCode == false)
				{
					throw new Exception($"An error({response.StatusCode}) was encountered attempting to PUT Expertise to {url}");
				}

				// The Response is a Person object, use it to update our Person variable
				var stringResult = await response.Content.ReadAsStringAsync();
				result = JsonConvert.DeserializeObject<Person>(stringResult, Json.JsonSerializerSettings);
			}
			
			// Everything updated, close the modal
			if(AddedByEnter == false)
			{
				Mf.Close();
			}

			// Invoking after close because the two-way binding can cause hiccups in the ModalForm.
			await PersonChanged.InvokeAsync(result);
			
			// We've saved our changes reset the bools that dicate the ModalForms behavior.
			ResetForm();
		}
		catch(Exception ex)
		{
			Ex = ex;
		}
		StateHasChanged();// Force it to redraw the component since the Expertise entries are drawn procedurally.
	}

	private async Task SearchTermChanged(string newValue)
	{
		//Console.WriteLine($"SearchTerm({SearchTerm}) changing to: {newValue}");
		SearchTerm = newValue;
		await UpdateSuggestions(newValue);
	}

	private class StackExchangeRequest
	{
		public Task Task { get; set; }
		public CancellationTokenSource TokenSource { get; set; }
	}

	private class SuggestionItem
	{
		public double Count { get; set; }
		public string Name { get; set; }
	}

	private class SuggestionResponse
	{
		public List<SuggestionItem> Items { get; set; }
	}

	private void CancelSuggestionsRequestIfRunning()
	{
		var acceptableTaskStatus = new List<TaskStatus> { TaskStatus.RanToCompletion, TaskStatus.Canceled };
		if(SuggestionsRequest != null && acceptableTaskStatus.Contains(SuggestionsRequest.Task.Status) == false)
		{
			SuggestionsRequest.TokenSource.Cancel();
		}
	}

	private async Task UpdateSuggestions(string searchTerm)
	{
		if(string.IsNullOrWhiteSpace(searchTerm))
		{
			Suggestions = new List<string>();
			return;
		}

		// Cancel any currently running requests to the Stack Exchange API that are currently running.
		CancelSuggestionsRequestIfRunning();

		// Make a cancelable request to the API and process the response.
		var ts = new CancellationTokenSource();
		SuggestionsRequest = new StackExchangeRequest
		{
			TokenSource = ts,
			Task = Task.Run(async () => {
				// Pause before sending the request in case the user isn't done typing.
				// Additional keystrokes will cancel this request.
				await Task.Delay(500);
				
				if(ts.Token.IsCancellationRequested == false)// Only procede if this task has not been canceled.
				{
					// Using a new client instead of API so we don't send the users bearer token to Stack Exchange
					using (var client = new HttpClient())
					{
						var response = await client.GetAsync($"https://api.stackexchange.com/2.2/tags?order=desc&site=stackoverflow&min=4000&sort=popular&inname={HttpUtility.UrlEncode(searchTerm.ToLower())}");
						// If this task was canceled before we got a response do not update Suggestions.
						if(ts.Token.IsCancellationRequested == false)
						{
							if(response.IsSuccessStatusCode)
							{
								var result = await response.Content.ReadFromJsonAsync<SuggestionResponse>();
								
								//Make sure the user's input is the first item in the list, with no duplicates.
								var rawSuggestions = result.Items.Select(i => i.Name).ToList();
								rawSuggestions.Remove(searchTerm.ToLower());
								rawSuggestions.Insert(0, searchTerm.ToLower());
								
								Suggestions = rawSuggestions.Take(10).ToList();
							}
							else
							{
								Suggestions = new List<string> { searchTerm.ToLower() };
							}
						}
					}
				}
			}, ts.Token)
		};

		await SuggestionsRequest.Task;
	}

	public void Dispose() { }
}